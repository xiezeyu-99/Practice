# LeetCode-15-three-sum

>题目链接

[LeetCode-15-three-sum](https://leetcode-cn.com/problems/3sum/)

>思路

1.先对数组进行升序排序，这样循环的过程中遇到相同的值就可以直接指针前移，跳过重复值

2.循环数组，

3.如果当前遍历到的值比0大，那右边不可能再存在有值，与当前值相加后等于0，直接跳过

4.当前值与前一个值相同，直接跳过

5.建立一个左指针，从当前值的下一个值的位置开始，从左往右移

6.建立一个右指针，从最后一个值的位置开始，从右往左移

7.如果左指针小于右指针，则计算左右指针对应的值与当前遍历的值的和

8.如果和等于0，将结果加入结果集，左指针的下一个值如果和左指针当前值相同，则指针右移，直到下一个值不相同或者左指针大于或等于右指针为止，右指针同理，然后两个指针同时移动

9.如果和比0大，需要减少组合元素的和，右边的指针左移

10.如果和比0小，需要增大组合元素的和，左边的指针右移

11.指针移动后继续重复7-10，直到两个指针相遇，然后数组进入下一个循环

>代码

```go
func threeSum(nums []int) [][]int {
	sort.Ints(nums)
	var result [][]int
	for i := 0; i < len(nums)-2;i++ {
		//nums经过了升序排序，如果当前的值比0大，那右边不可能再存在有值，与当前值相加后等于0
		if nums[i] > 0{
			continue
		}
		//因为要求结果不重复，对于相同的值不再进行处理
		if i!=0&&nums[i]==nums[i-1]{
			continue
		}
		l:=i+1//左指针，从下一个值的位置开始，从左往右移
		r:=len(nums)-1//右指针，从最后一个值的的位置开始，从右往左移

		//从两边同时往中间遍历，理论上可减少一半的循环次数
		for l < r{

			if nums[i]+nums[l]+nums[r] == 0 {
				//当前遍历到的值的和等于0，加入结果集合
				result = append(result, []int{nums[i],nums[l],nums[r]})

				//下一个值是相同的值，则最终组合出来的结果也是重复的，所以跳过
				for l<r&& nums[l] == nums[l+1] {
					l++
				}
				for l<r && nums[r] == nums[r-1] {
					r--
				}
				//两个指针同时移动
				l++
				r--
			} else if nums[i]+nums[l]+nums[r] > 0 {
				//当前遍历到的值的和比0大，需要减少组合元素的和，右边的指针左移
				r--
			} else {
				//当前遍历到的值的和比0小，需要增大组合元素的和，左边的指针右移
				l++
			}
		}
	}
	return result
}
```

>复杂度分析

时间复杂度：排序方法底层采用的是快速排序，时间复杂度O(nlogn)，循环求和O(n^2)，最终时间复杂度为O(n^2)

空间复杂度：存储两个常量级指针，O(1)

>总结

排序+双指针遍历法，

执行用时 :28 ms, 在所有 Go 提交中击败了99.19%的用户

内存消耗 :6.9 MB, 在所有 Go 提交中击败了66.33%的用户
